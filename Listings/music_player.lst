C51 COMPILER V9.59.0.0   MUSIC_PLAYER                                                      05/15/2025 00:04:18 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MUSIC_PLAYER
OBJECT MODULE PLACED IN .\Objects\music_player.obj
COMPILER INVOKED BY: E:\keil\C51\BIN\C51.EXE music_player.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\music_player.lst) TABS(2) OBJECT(.\Objects\music_player.obj)

line level    source

   1          #include "music_player.h"
   2          #include "music_data.h" // For FreqTable, Songs, Song_Names, NUM_SONGS
   3          
   4          //-----------------------------------------------------------------------------
   5          // Module-Private Variables
   6          //-----------------------------------------------------------------------------
   7          static PlayerState G_player_state;
   8          // G_current_song_data_ptr points to data in CODE memory. The pointer itself resides in RAM.
   9          static const unsigned char code * G_current_song_data_ptr;
  10          static unsigned int G_current_song_note_index;
  11          static unsigned int G_current_tempo;
  12          static unsigned char G_current_freq_select;
  13          static unsigned int G_note_duration_tick_counter;
  14          static unsigned int G_time_since_last_note_ms;
  15          static unsigned char G_freq_table_offset = 0;
  16          
  17          
  18          //-----------------------------------------------------------------------------
  19          // Private Helper Functions
  20          //-----------------------------------------------------------------------------
  21          static void delay_ms_software(unsigned int ms) {
  22   1          unsigned char i, j;
  23   1          while (ms--) {
  24   2              _nop_();
  25   2              i = 2;
  26   2              j = 199;
  27   2              do {
  28   3                  while (--j);
  29   3              } while (--i);
  30   2          }
  31   1      }
  32          
  33          static void timer0_init_for_music(void) {
  34   1          TMOD &= 0xF0;
  35   1          TMOD |= 0x01;
  36   1          TL0 = 0x18;
  37   1          TH0 = 0xFC;
  38   1          TF0 = 0;
  39   1          TR0 = 0;
  40   1          ET0 = 1;
  41   1          PT0 = 0;
  42   1      }
  43          
  44          static void play_next_note(void) {
  45   1          unsigned char duration_multiplier;
  46   1          unsigned int timer_reload_val;
  47   1      
  48   1          if (G_player_state != PLAYER_PLAYING || G_current_song_data_ptr == 0) {
  49   2              Music_Stop();
  50   2              return;
  51   2          }
  52   1      
  53   1          G_current_freq_select = G_current_song_data_ptr[G_current_song_note_index];
  54   1          
C51 COMPILER V9.59.0.0   MUSIC_PLAYER                                                      05/15/2025 00:04:18 PAGE 2   

  55   1          if (G_current_freq_select == SONG_END_MARKER) {
  56   2              Music_Stop();
  57   2              return;
  58   2          }
  59   1      
  60   1          G_current_song_note_index++;
  61   1          duration_multiplier = G_current_song_data_ptr[G_current_song_note_index];
  62   1          G_current_song_note_index++;
  63   1      
  64   1          G_note_duration_tick_counter = (G_current_tempo / 4) * duration_multiplier;
  65   1          G_time_since_last_note_ms = 0;
  66   1      
  67   1          if (G_current_freq_select == NOTE_P) {
  68   2              TR0 = 0;
  69   2              BUZZER_PIN = 0;
  70   2          } else {
  71   2              if (!TR0) {
  72   3                  timer_reload_val = FreqTable[G_current_freq_select + G_freq_table_offset];
  73   3                  TL0 = timer_reload_val % 256;
  74   3                  TH0 = timer_reload_val / 256;
  75   3                  TR0 = 1;
  76   3              }
  77   2          }
  78   1      }
  79          
  80          //-----------------------------------------------------------------------------
  81          // Public Function Implementations
  82          //-----------------------------------------------------------------------------
  83          void Music_Init(unsigned int initial_tempo) {
  84   1          timer0_init_for_music();
  85   1          G_current_tempo = initial_tempo > 0 ? initial_tempo : 500;
  86   1          G_player_state = PLAYER_STOPPED;
  87   1          G_current_song_data_ptr = 0;
  88   1          G_current_song_note_index = 0;
  89   1          G_current_freq_select = NOTE_P;
  90   1          G_note_duration_tick_counter = 0;
  91   1          G_time_since_last_note_ms = 0;
  92   1          BUZZER_PIN = 0;
  93   1      }
  94          
  95          void Music_PlaySong(unsigned char song_index) {
  96   1          if (song_index >= NUM_SONGS) {
  97   2              return;
  98   2          }
  99   1          Music_Stop();
 100   1          G_current_song_data_ptr = Songs[song_index];
 101   1          G_current_song_note_index = 0;
 102   1          G_player_state = PLAYER_PLAYING;
 103   1          play_next_note();
 104   1      }
 105          
 106          void Music_Stop(void) {
 107   1          TR0 = 0;
 108   1          BUZZER_PIN = 0;
 109   1          G_player_state = PLAYER_STOPPED;
 110   1          G_current_song_data_ptr = 0;
 111   1          G_current_song_note_index = 0;
 112   1          G_current_freq_select = NOTE_P;
 113   1          G_note_duration_tick_counter = 0;
 114   1          G_time_since_last_note_ms = 0;
 115   1      }
 116          
C51 COMPILER V9.59.0.0   MUSIC_PLAYER                                                      05/15/2025 00:04:18 PAGE 3   

 117          void Music_Pause(void) {
 118   1          if (G_player_state == PLAYER_PLAYING) {
 119   2              TR0 = 0;
 120   2              G_player_state = PLAYER_PAUSED;
 121   2          }
 122   1      }
 123          
 124          void Music_Resume(void) {
 125   1          unsigned int timer_reload_val;
 126   1          if (G_player_state == PLAYER_PAUSED) {
 127   2              G_player_state = PLAYER_PLAYING;
 128   2              if (G_current_freq_select != NOTE_P) {
 129   3                  timer_reload_val = FreqTable[G_current_freq_select + G_freq_table_offset];
 130   3                  TL0 = timer_reload_val % 256;
 131   3                  TH0 = timer_reload_val / 256;
 132   3                  TR0 = 1;
 133   3              }
 134   2          }
 135   1      }
 136          
 137          void Music_SetTempo(unsigned int new_tempo) {
 138   1          if (new_tempo > 0) {
 139   2              G_current_tempo = new_tempo;
 140   2          }
 141   1      }
 142          
 143          PlayerState Music_GetState(void) {
 144   1          return G_player_state;
 145   1      }
 146          
 147          unsigned char Music_GetTotalSongs(void) {
 148   1          return NUM_SONGS;
 149   1      }
 150          
 151          // Definition of Music_GetSongName.
 152          // Its declaration in music_player.h must match this signature.
 153          const char code * Music_GetSongName(unsigned char song_index) {
 154   1          if (song_index < NUM_SONGS) {
 155   2              return Song_Names[song_index];
 156   2          }
 157   1          return 0; // NULL pointer
 158   1      }
 159          
 160          void Music_Player_Tick(void) {
 161   1          if (G_player_state == PLAYER_PLAYING) {
 162   2              G_time_since_last_note_ms++;
 163   2              if (G_time_since_last_note_ms >= G_note_duration_tick_counter) {
 164   3                  if (G_current_song_data_ptr != 0 && G_current_song_data_ptr[G_current_song_note_index] != SONG
             -_END_MARKER) {
 165   4                       TR0 = 0; 
 166   4                       BUZZER_PIN = 0;
 167   4                  }
 168   3                  play_next_note();
 169   3              }
 170   2          }
 171   1      }
 172          
 173          //-----------------------------------------------------------------------------
 174          // Timer0 Interrupt Service Routine
 175          //-----------------------------------------------------------------------------
 176          void Music_Timer0_ISR(void) interrupt 1 using 1 { // 'using 1' selects register bank 1
 177   1          unsigned int reload_value;
C51 COMPILER V9.59.0.0   MUSIC_PLAYER                                                      05/15/2025 00:04:18 PAGE 4   

 178   1          if (G_player_state == PLAYER_PLAYING && G_current_freq_select != NOTE_P) {
 179   2              reload_value = FreqTable[G_current_freq_select + G_freq_table_offset];
 180   2              TL0 = reload_value % 256;
 181   2              TH0 = reload_value / 256;
 182   2              BUZZER_PIN = !BUZZER_PIN;
 183   2          } else {
 184   2              BUZZER_PIN = 0;
 185   2          }
 186   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    550    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
