C51 COMPILER V9.59.0.0   MAIN                                                              05/15/2025 00:07:29 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.ls
                    -t) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "music_player.h"
   3          #include "music_data.h"
   4          #include "keypad.h"
   5          
   6          // --- LCD related includes and defines would go here ---
   7          // #include "lcd1602.h" // Example: sbit LCD_RS = P2^0; ...
   8          
   9          // --- Global variables for application state ---
  10          unsigned char G_selected_song_index = 0; // Start with the first song (index 0)
  11          
  12          // --- Keypad debouncing variables ---
  13          static unsigned char s_key_current_reading = KEY_NONE;
  14          static unsigned char s_key_debounced_state = KEY_NONE;
  15          static unsigned char s_key_last_debounced_state = KEY_NONE;
  16          static unsigned char s_key_debounce_count = 0;
  17          #define KEY_DEBOUNCE_CHECKS 3 // Number of consecutive identical readings for a stable state
  18          
  19          // Simple delay for main loop if needed for debouncing timing
  20          void delay_ms_main(unsigned int ms) {
  21   1          unsigned int i, j;
  22   1          for (i = 0; i < ms; i++) {
  23   2              for (j = 0; j < 120; j++); // Adjust for crystal frequency (e.g., for ~1ms at 11.0592MHz)
  24   2          }
  25   1      }
  26          
  27          //-----------------------------------------------------------------------------
  28          // Timer1 ISR for 1ms Tick (to call Music_Player_Tick)
  29          //-----------------------------------------------------------------------------
  30          #define TIMER1_RELOAD_VAL_1MS 0xFC66 // For 11.0592MHz, for 1ms interrupt
  31          
  32          void Timer1_Init_1ms(void) {
  33   1          TMOD &= 0x0F; // Clear Timer1 bits
  34   1          TMOD |= 0x10; // Set Timer1 to Mode 1 (16-bit timer)
  35   1          TH1 = TIMER1_RELOAD_VAL_1MS / 256; // Load high byte for 1ms
  36   1          TL1 = TIMER1_RELOAD_VAL_1MS % 256; // Load low byte for 1ms
  37   1          TF1 = 0; // Clear Timer1 overflow flag
  38   1          ET1 = 1; // Enable Timer1 interrupt
  39   1          TR1 = 1; // Start Timer1
  40   1      }
  41          
  42          void Timer1_ISR(void) interrupt 3 { // Timer1 Interrupt vector (usually 3 for 8051)
  43   1          TH1 = TIMER1_RELOAD_VAL_1MS / 256; // Reload Timer1 for next 1ms interrupt
  44   1          TL1 = TIMER1_RELOAD_VAL_1MS % 256;
  45   1          Music_Player_Tick(); // Drive the music player rhythm
  46   1      }
  47          
  48          //-----------------------------------------------------------------------------
  49          // Main Function
  50          //-----------------------------------------------------------------------------
  51          void main() {
  52   1          unsigned char processed_key_press = KEY_NONE; // To store the key event
  53   1          PlayerState current_music_state; // To store current music player state
  54   1      
C51 COMPILER V9.59.0.0   MAIN                                                              05/15/2025 00:07:29 PAGE 2   

  55   1          // --- System Initializations ---
  56   1          // LCD_Init(); // Initialize your LCD if you have one
  57   1          Keypad_Init();      // Initialize keypad I/O
  58   1          Music_Init(500);    // Initialize music player (tempo 300 is an example)
  59   1          Timer1_Init_1ms();  // Initialize Timer1 for music ticks
  60   1      
  61   1          EA = 1; // Enable Global Interrupts *AFTER* all other initializations
  62   1      
  63   1          // --- Initial Display & Autoplay ---
  64   1          // LCD_ShowString(0, 0, "Music Box Autoplay"); // Example LCD message
  65   1          // LCD_ShowString(1, 0, "Playing: ");
  66   1          // LCD_ShowString(1, 9, Music_GetSongName(G_selected_song_index)); // Display initial song name
  67   1      
  68   1          Music_PlaySong(G_selected_song_index); // Autoplay the first song on power-on
  69   1      
  70   1          s_key_last_debounced_state = Keypad_GetImmediateKeyState(); // Initialize last keypad state for edge d
             -etection
  71   1      
  72   1          while (1) {
  73   2              // --- Keypad Debouncing and Edge Detection ---
  74   2              s_key_current_reading = Keypad_GetImmediateKeyState();
  75   2      
  76   2              if (s_key_current_reading == s_key_debounced_state) {
  77   3                  s_key_debounce_count = 0; // Reset counter if reading is stable
  78   3              } else {
  79   3                  s_key_debounce_count++;
  80   3                  if (s_key_debounce_count >= KEY_DEBOUNCE_CHECKS) {
  81   4                      s_key_debounce_count = 0;
  82   4                      s_key_debounced_state = s_key_current_reading;
  83   4      
  84   4                      if (s_key_debounced_state != KEY_NONE && s_key_last_debounced_state == KEY_NONE) {
  85   5                          processed_key_press = s_key_debounced_state;
  86   5                      }
  87   4                      s_key_last_debounced_state = s_key_debounced_state;
  88   4                  }
  89   3              }
  90   2      
  91   2              // --- Process Key Press Event ---
  92   2              if (processed_key_press != KEY_NONE) {
  93   3                  current_music_state = Music_GetState(); // Get current player state before processing key
  94   3      
  95   3                  switch (processed_key_press) {
  96   4                      case KEY_S13: // Play/Pause (mapped to S13)
  97   4                          if (current_music_state == PLAYER_PLAYING) {
  98   5                              Music_Pause();
  99   5                              // if (LCD_IsInitialized()) { LCD_ShowString(0, 0, "Paused!         "); }
 100   5                          } else if (current_music_state == PLAYER_PAUSED) {
 101   5                              Music_Resume(); // <<<--- CORRECTED: Resume from paused state
 102   5                              // if (LCD_IsInitialized()) { LCD_ShowString(0, 0, "Resuming...     "); }
 103   5                          } else { // PLAYER_STOPPED or other initial states
 104   5                              Music_PlaySong(G_selected_song_index);
 105   5                              // if (LCD_IsInitialized()) {
 106   5                              //     LCD_ShowString(0, 0, "Playing:        ");
 107   5                              //     LCD_ShowString(1, 9, Music_GetSongName(G_selected_song_index));
 108   5                              // }
 109   5                          }
 110   4                          break;
 111   4      
 112   4                      case KEY_S14: // Next Song (mapped to S14)
 113   4                          G_selected_song_index++;
 114   4                          if (G_selected_song_index >= Music_GetTotalSongs()) {
 115   5                              G_selected_song_index = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              05/15/2025 00:07:29 PAGE 3   

 116   5                          }
 117   4                          Music_PlaySong(G_selected_song_index);
 118   4                          // if (LCD_IsInitialized()) {
 119   4                          //     LCD_ShowString(0, 0, "Next Song:      ");
 120   4                          //     LCD_ShowString(1, 9, Music_GetSongName(G_selected_song_index));
 121   4                          // }
 122   4                          break;
 123   4      
 124   4                      case KEY_S15: // Previous Song (mapped to S15)
 125   4                          if (G_selected_song_index == 0) {
 126   5                              G_selected_song_index = Music_GetTotalSongs() - 1;
 127   5                          } else {
 128   5                              G_selected_song_index--;
 129   5                          }
 130   4                          Music_PlaySong(G_selected_song_index);
 131   4                          // if (LCD_IsInitialized()) {
 132   4                          //     LCD_ShowString(0, 0, "Prev Song:      ");
 133   4                          //     LCD_ShowString(1, 9, Music_GetSongName(G_selected_song_index));
 134   4                          // }
 135   4                          break;
 136   4      
 137   4                      case KEY_S16: // Stop (mapped to S16)
 138   4                          Music_Stop();
 139   4                          // if (LCD_IsInitialized()) { LCD_ShowString(0,0,"Stopped.        "); }
 140   4                          break;
 141   4      
 142   4                      default:
 143   4                          break;
 144   4                  }
 145   3                  processed_key_press = KEY_NONE; // Clear the event after processing
 146   3              }
 147   2              delay_ms_main(10);
 148   2          }
 149   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    295    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
